r1. What is Service?
Ans. A service is a component that runs in the background to perform 
long-running operations without needing to interact with the user and
it works even if application is destroyed. A service can essentially
take two states :

Started Service - A service is started when an application component,
such as an activity, starts it by calling startService().
Once started, a service can run in the background indefinitely,
even if the component that started it is destroyed.

Bound Service -	A service is bound when an application component binds
to it by calling bindService(). A bound service offers a client-server
interface that allows components to interact with the service, send
requests, get results, and even do so across processes with 
interprocess communication (IPC).

Life cycle of service
onStartCommand() - The system calls this method when another component,
such as an activity, requests that the service be started, by calling startService().
If you implement this method, it is your responsibility to stop the 
service when its work is done, by calling stopSelf() or stopService() methods.

onBind() - The system calls this method when another component wants to
bind with the service by calling bindService(). If you implement this
method, you must provide an interface that clients use to communicate
with the service, by returning an IBinder object. You must always
implement this method, but if you don't want to allow binding,
then you should return null.

onUnbind() - The system calls this method when all clients have 
disconnected from a particular interface published by the service.

onRebind() - The system calls this method when new clients have connected
to the service, after it had previously been notified that all had 
disconnected in its onUnbind(Intent).

onCreate() - The system calls this method when the service is first created
using onStartCommand() or onBind(). This call is required to perform one-time set-up.

onDestroy() - The system calls this method when the service is no longer
used and is being destroyed. Your service should implement this to clean
up any resources such as threads, registered listeners, receivers, etc.


Caution: A service runs in the main thread of its hosting process—the service does not create its own thread and does not run in a separate process (unless you specify otherwise). This means that, if your service is going to do any CPU intensive work or blocking operations (such as MP3 playback or networking), you should create a new thread within the service to do that work. By using a separate thread, you will reduce the risk of Application Not Responding (ANR) errors and the application's main thread can remain dedicated to user interaction with your activities.

If you need to perform work outside your main thread, but only while the user is interacting with your application, then you should probably instead create a new thread and not a service. For example, if you want to play some music, but only while your activity is running, you might create a thread in onCreate(), start running it in onStart(), then stop it in onStop(). Also consider using AsyncTask or HandlerThread, instead of the traditional Thread class. See the Processes and Threading document for more information about threads.

2. Where does service runs?
Ans. Service runs in main thread. Then, they would ask why should we use service. 
Answer for that would be, if we want to do some small work or small data download
from server. If there is huge processing of data we can do it using Intent Service
or we can start a thread within the service or we can use threads for that.

3. What is ANR?
Ans. We get ANR(Android Not Responding)if we are doing heavy functionality along
with the UI in the main thread. If two heavy functionality happen in single thread,
it will delay response to user actions and hence stop your processes. This ANR
occurs if the UI doesn't respond for 5seconds

4. Within what time the functionality within the onReceive Method of broadcast should be executed?
Ans. 10seconds

5. What are the types of broadcast receivers?
Ans.Normal Broadcast

		:- use sendBroadcast()

		:- asynchronous broadcast

		:- any receiver receives broadcast not any particular order

	Ordered Broadcast

		:- use sendOrderedBroadcast()

		:- synchronous broadcast

		:- receiver receives broadcast in priority base

		:- we can also simply abort broadcast in this type

	Local Broadcast

		:- use only when broadcast is used only inside same process

	Sticky Broadcast

		:- normal broadcast intent is not available any more after is was send and processed by the system.

		:- use sendStickyBroadcast(Intent)

		:- the corresponding intent is sticky, meaning the intent you are sending stays around after the 
broadcast is complete.

		:- because of this others can quickly retrieve that data through the return value of 
registerReceiver(BroadcastReceiver, IntentFilter).

		:- apart from this same as sendBroadcast(Intent).
		
		Ex: Intent intent = new Intent("some.custom.action");
			intent.putExtra("some_boolean", true);
			sendStickyBroadcast(intent);

6. How to cancel AsyncTask?
Ans. A task can be cancelled at any time by invoking cancel(boolean). Invoking this method will cause subsequent
 calls to isCancelled()
to return true. After invoking this method, onCancelled(Object), instead of onPostExecute(Object) will be invoked
 after doInBackground(Object[])
returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of
 isCancelled() periodically
from doInBackground(Object[]), if possible (inside a loop for instance.) 

So as per the above description, we need to implement two things to stop the AsyncTask execution:

	1. call Cancel() method of AsyncTask from where you want to stop the execution, may be based on the 
button click.	
		asyncTask.cancel(true);

	2. Now you have to check whether the AsyncTask is cancelled or not by using isCancelled method inside 
the doInBackground method.
	
		protected Object doInBackground(Object... x)  { 
 
			while (/* condition */)
			{
				if (isCancelled())  
				break;
			} 
			return null; 
		}
		
7. How do you restore edit text values which has been entered if the screen rotates from portrait to landscape?
Ans. We save the values in saved instance state method and we retrieve the values in restore Saved Instance State method
		protected void onSaveInstanceState(Bundle outState) {
			super.onSaveInstanceState(outState);
			Log.i(TAG, "onSaveInstanceState");
		
			final EditText textBox = 
                (EditText) findViewById(R.id.editText1);
			
			// Having obtained a reference to the EditText object and assigned it to textBox from the above code,
			// we can now obtain the text that it contains by calling the object’s getText() method, which, in turn,
			// returns the current text in the form of a CharSequence object:
			CharSequence userText = textBox.getText();
			
			// Finally, we can save the text using the Bundle object’s putCharSequence() method, passing through the key
			// (this can be any string value but in this instance, we will declare it as “savedText”) and the userText 
			// object as arguments:
			outState.putCharSequence("savedText", userText);
		}
		
		protected void onRestoreInstanceState(Bundle savedState) {		
			Log.i(TAG, "onRestoreInstanceState");
		
			final EditText textBox = 
               (EditText) findViewById(R.id.editText1);
		
			CharSequence userText = 
               savedState.getCharSequence("savedText");
		
			textBox.setText(userText);
		}

8. What is intent service?
Ans. IntentService is a subclass of android.app.Service class. A stated intent service allows to handle long running 
tasks
without effecting the application UI thread. This is not bound to any activity so, it is not getting effected for any change
in activity life cycle. Once IntentService is started, it handles each Intent using a worker thread and stops itself when it
runs out of work.

This "work queue processor" pattern is commonly used to offload tasks from an application's main thread. The IntentService class exists to simplify this pattern and take care of the mechanics. To use it, extend IntentService and implement onHandleIntent(Intent). IntentService will receive the Intents, launch a worker thread, and stop the service as appropriate. 

IntentService would be an best solution, If you have an work queue to process. For example, if your application using analytics
you will likely to send event name and related parameter to your tracking server for each user generated event. Although each
event means a tiny piece of data, creating networking request on each click will result an overhead to your application.
Instead, you can use work queue processor design pattern and process the events in a batch.

Disadvantages :
	1. No easy or direct way to interact with user interface directly from IntentService. Later in this example, we will explain
	to pass result back from IntentService to
	2. With IntentService, there can only be one request processed at any single point of time. If you request for another task,
	then the new job will wait until the previous one is completed. This means that IntentService process the request
	3. An tasks stated using IntentService cannot be interrupted

9. What is view holder?
Ans. The ViewHolder design pattern enables you to access each list item view without the need for the look up, saving valuable
processor cycles. Specifically, it avoids frequent call of findViewById() during ListView scrolling, and that will make it smooth.

Without view holder how it works:
	The first time it was loaded, convertView is null. We’ll have to inflate our list item layout and find the TextView via findViewById().
	
	The second time it was loaded, convertView is not null, good! We don’t have to inflate it again. But we’ll use findViewById() again.
	
	The following times it was loaded, convertView is definitely not null. But findViewById() is constantly called, it will work but,
	it slows down the performance especially if you have lots of items and Views in your ListView.
	
With View Holder:
	The first time it was loaded, convertView is null. We’ll have to inflate our list item layout, instantiate the ViewHolder,
	find the TextView via findViewById() and assign it to the ViewHolder, and set the ViewHolder as tag of convertView.
	
	The second time it was loaded, convertView is not null, good! We don’t have to inflate it again. And here’s the sweet thing,
	we won’t have to call findViewById() since we can now access the TextView via its ViewHolder.
	
	The following time it was loaded, convertView is definitely not null. The findViewById() is never called again, and that makes
	our smooth ListView scrolling.
	
10. What is intent filter?
Ans. An intent filter is an expression in an app's manifest file that specifies the type of intents that the 
component
would like to receive.

When you create an implicit intent, the Android system finds the appropriate component to start by comparing 
the contents
of the intent to the intent filters declared in the manifest file of other apps on the device. If the intent 
matches an intent
filter, the system starts that component and delivers it the Intent object.

11. What are handlers?
Ans. Since, threads cannot update the ui all by itself, we use handlers. Handlers are used to update the UI 
from threads.



12.What is the difference between Services, Thread and an AsyncTask in Android?


 
Service is like an Activity but has no interface. Probably if you want to fetch the weather for example you 
won’t create a blank activity for it, for this you will use a Service.

A Thread is a Thread, probably you already know it from other part. You need to know that you cannot update UI 
from a Thread. You need to use a Handler for this, but read further.


 
An AsyncTask is an intelligent Thread that is advised to be used. Intelligent as it can help with it’s methods, 
and there are two methods that run on UI thread, which is good to update UI components.


13.The advantages and disadvantages of a Asynctask?



An AsyncTask has several parts: a doInBackground method that does, in fact, run on a separate thread, and a onPostExecute method that runs on the UI thread. The purpose of onPostExecute is to publish results (such as updating the view hierarchy, or setting text in a text view) that must be done on the UI thread. It also can post progress updates. In order for this to all work properly, the AsyncTask must be created, and the execute method called, on the UI thread.

You must not call UI actions from within doInBackground -- doing so will crash your application.


AsyncTask,Asynchronous Android provides lightweight, can be directly inherited AsyncTask, realize the asynchronous 
operation in the class, and provides the interface feedback current asynchronous execution degree (UI can achieve
 progress updates through the interface), finally feedback implementation of the results to the UI main thread

Advantage:

1 simple, quick

2 process control

3 disadvantages of using:

Disadvantages: when using multiple asynchronous operations and and the need for Ui change, will become more 
complicated


Android AsyncTask Handler more than a lightweight, suitable for asynchronous processing simple. 
The first clear Android is Handler and AsyncTask, are not to block the main thread (UI thread), and UI updates 
only completed in the main thread, so the asynchronous processing is inevitable

Android in order to reduce the difficulty of development, provides AsyncTask. The background task class AsyncTask
 is a package of, as the name suggests is the asynchronous task.

AsyncTask inherits from the Object class, position android.os.AsyncTask. To use the AsyncTask work for us to 
provide three generic parameters, several method overloading and (at least overload a)

AsyncTask defines three kinds of generic types Params, Progress and Result.

Params enable input parameters task execution, such as HTTP request URL. 
The percentage of Progress background tasks. 
Result background mission eventually return results, such as String. 





14.A “launch mode” is the way in which a new instance of an activity is to be associated with the current task.

Launch modes may be defined using one of two mechanisms:

Manifest file. When declaring an activity in a manifest file, you can specify how the activity should associate 
with tasks when it starts. Supported values include:

standard (default). Creates a new instance of the activity in the task from which it was started and route the 
intent to it.
singleTop. If an instance of the activity already exists at the top of the current task, the system routes the 

intent to that instance through a call to its onNewIntent() method, rather than creating a new instance of the 
activity.
singleTask. Creates a new task and instantiates the activity at the root of the new task. However, if an instance
 of the activity already exists in a separate task, the system instead routes the intent to the existing instance
 through a call to its onNewIntent() method. Only one instance of the activity can exist at a time.
Intent flags. Calls to startActivity() can include a flag in the Intent that declares if and how the new
 activity should be associated with the current task. Supported values include:

FLAG_ACTIVITY_NEW_TASK. Same as singleTask value in Manifest file (see above).
FLAG_ACTIVITY_SINGLE_TOP. Same as singleTop value in Manifest file (see above).
FLAG_ACTIVITY_CLEAR_TOP. If the activity being started is already running in the current task, then instead of 
launching a new instance of that activity, all of the other activities on top of it are destroyed and this intent
 is delivered to the resumed instance of the activity (now on top), through onNewIntent(). There is no 
corresponding value in the Manifest file that produces this behavior.

"standard" (the default mode)
Default. The system creates a new instance of the activity in the task from which it was started and routes 
the intent to it. The activity can be instantiated multiple times, each instance can belong to different tasks, 
and one task can have multiple instances.
"singleTop"
If an instance of the activity already exists at the top of the current task, the system routes the intent to 
that instance through a call to its onNewIntent() method, rather than creating a new instance of the activity. 
The activity can be instantiated multiple times, each instance can belong to different tasks, and one task can 
have multiple instances (but only if the activity at the top of the back stack is not an existing instance of 
the activity).
For example, suppose a task's back stack consists of root activity A with activities B, C, and D on top 
(the stack is A-B-C-D; D is on top). An intent arrives for an activity of type D. If D has the default 
"standard" launch mode, a new instance of the class is launched and the stack becomes A-B-C-D-D. However,
 if D's launch mode is "singleTop", the existing instance of D receives the intent through onNewIntent(), 
because it's at the top of the stack—the stack remains A-B-C-D. However, if an intent arrives for an activity
 of type B, then a new instance of B is added to the stack, even if its launch mode is "singleTop".

Note: When a new instance of an activity is created, the user can press the Back button to return to the 
previous activity. But when an existing instance of an activity handles a new intent, the user cannot press 
the Back button to return to the state of the activity before the new intent arrived in onNewIntent().

"singleTask"
The system creates a new task and instantiates the activity at the root of the new task. However, if an 
instance of the activity already exists in a separate task, the system routes the intent to the existing 
instance through a call to its onNewIntent() method, rather than creating a new instance. Only one instance 
of the activity can exist at a time.
Note: Although the activity starts in a new task, the Back button still returns the user to the previous activity.

"singleInstance".
Same as "singleTask", except that the system doesn't launch any other activities into the task holding the 
instance. The activity is always the single and only member of its task; any activities started by this one
 open in a separate task.



15.What is Layoutinflater ?

LayoutInflater class is used to instantiate layout XML file into its corresponding View objects.

In other words, it takes as input an XML file and builds the View objects from it.

LayoutInflater is a class (wrapper of some implementation or service), you can get one:

LayoutInflater li = LayoutInflater.from(context);

How to use Layoutinflater?

You feed it an XML layout file. You need not give full file address, just its resource id, generated for 
you automatically in R class. For example, a layout file which look like:



The method findViewById() returns an instance of the class that is actually used to 
define that view in your XML file. The method signature returns a View to make it generic and usable for all
 classes that inherit for View.


16.Shared Preferences?
Most Android apps needs  to save data about the application state so that users progress is not lost. 
SharedPreferences API in android lets us to save data in key-value sets. When there is a need to save small 
collection of key-values we should use Android SharedPreferences.
A SharedPreferences object points to a file containing key-value pairs and provides simple methods to read and 
write them. Each SharedPreferences file is managed by the framework and can be private or shared.

sharedpreferences = getSharedPreferences(mypreference,Context.MODE_PRIVATE);


Editor editor = sharedpreferences.edit();
editor.putString(Name, n);
editor.putString(Email, e);
editor.commit();

Get data from sharedpreference
          sharedpreferences.getString() method should be used to get the values for 
corresponding keys as shown below

		if (sharedpreferences.contains(Name)) {
			sharedpreferences.getString(Name, "");
		}
		if (sharedpreferences.contains(Email)) {
			sharedpreferences.getString(Email, "");

 		}




17.Different Type of Fragments In Android?

DialogFragment
Displays a floating dialog. Using this class to create a dialog is a good alternative to using the dialog helper 
methods in the Activity class, because you can incorporate a fragment dialog into the back stack of fragments managed by the activity,
 allowing the user to return to a dismissed fragment.

ListFragment
Displays a list of items that are managed by an adapter (such as a SimpleCursorAdapter), similar to ListActivity. It provides several 
methods for managing a list view, such as the onListItemClick() callback to handle click events.

PreferenceFragment
Displays a hierarchy of Preference objects as a list, similar to PreferenceActivity. This is useful when creating a "settings" 
activity for your application.





18.What is AsyncTask?
               AsyncTask is an abstract class provided by Android which helps us to use the UI thread properly. This class allows us to 
perform long/background operations and show its result on the UI thread without having to manipulate threads.

When to use AsyncTask?
            Android implements single thread model and whenever an android application is launched, a thread is created. Assuming we are doing 
network operation on a button click in our application. On button click a request would be made to the server and response will be awaited. 
Due to single thread model of android, till the time response is awaited our screen is non-responsive. So we should avoid performing long running 
operations on the UI thread. This includes file and network access.
            To overcome this we can create new thread and implement run method to perform this network call, so UI remains responsive.
            But since Android follows single thread model and Android UI toolkit is not thread safe, so if there is a need to make some change to 
the UI based on the result of the operation performed, then this approach may lead some issues.

So the Android framework has given a very good pattern which is enveloped into AsyncTask.

Note: AsyncTask should ideally be used for operations that take few seconds. Some tasks keep the thread running for long time so in that case it is 
recommended to use java.util.concurrent package such as Executor, ThreadPoolExecutor and FutureTask.

AsyncTask has four steps:

doInBackground: Code performing long running operation goes in this method.  When onClick method is executed on click of button, it calls execute method 
which accepts parameters and automatically calls doInBackground method with the parameters passed.
onPostExecute: This method is called after doInBackground method completes processing. Result from doInBackground is passed to this method.
onPreExecute: This method is called before doInBackground method is called.
onProgressUpdate: This method is invoked by calling publishProgress anytime from doInBackground call this method.




19.What are sp, dp, dip, dpi, px and when should they be used?

is Android tutorial is to explain the difference between dp, dip, sp, px, in, mm, pt and what we should use when. 
This is to enable design a consistent UI across different Android screen sizes. Before going into the difference let us 
understand some basic terminologies. Screen size in Android is grouped into categories small, medium, large, extra large, 
double-extra and triple-extra. Screen density is the amount of pixels within an area (like inch) of the screen. Generally it is 
measured in dots-per-inch (dpi). Screen density is grouped as low, medium, high and extra high. Resolution is the total number of pixels in the screen.

dp: Density Independent Pixel, it varies based on screen density . In 160 dpi screen, 1 dp = 1 pixel. Except for font size, use dp always.
dip: dip == dp. In earlier Android versions dip was used and later changed to dp.
sp: Scale Independent Pixel, scaled based on user’s font size preference. Fonts should use sp.
px: our usual standard pixel which maps to the screen pixel.
in: inches, with respect to the physical screen size.
mm: millimeters, with respect to the physical screen size.
pt: 1/72 of an inch, with respect to the physical screen size.
Always use dp and sp only. sp for font sizes and dp for everything else. It will make UI compatible for Android devices with different densities.

20.What is put, get post, delete in web services?

HTTP methods

Use HTTP methods to map CRUD (create, retrieve, update, delete) operations to HTTP requests.

GET

Retrieve information. GET requests must be safe and idempotent, meaning regardless of how many times it repeats with the same parameters,
 the results are the same. They can have side effects, but the user doesn't expect them, so they cannot be critical to the operation of the system. 
Requests can also be partial or conditional.

Retrieve an address with an ID of 1:

GET /addresses/1
POST

Request that the resource at the URI do something with the provided entity. Often POST is used to create a new entity, but it can also be used to 
update an entity.

Create a new address:

POST /addresses
PUT

Store an entity at a URI. PUT can create a new entity or update an existing one. A PUT request is idempotent. Idempotency is the main difference 
between the expectations of PUT versus a POST request.

Modify the address with an ID of 1:

PUT /addresses/1
Note: PUT replaces an existing entity. If only a subset of data elements are provided, the rest will be replaced with empty or null.
PATCH

Update only the specified fields of an entity at a URI. A PATCH request is idempotent. Idempotency is the main difference between the expectations o
f PUT versus a POST request.

PATCH /addresses/1
DELETE

Request that a resource be removed; however, the resource does not have to be removed immediately. It could be an asynchronous or long-running request.

Delete an address with an ID of 1:





21.Can we create an android project without an activity?If so how do you achieve it?
I've an application which aims to run only as a service (no interface, just run in background). 
I have no activity mentioned in my AndroidManifest.xml but put a receiver to start the application at phone start.

<application
    android:icon="@drawable/ic_launcher"
    android:label="@string/app_name" >
    <service
        android:enabled="true"
        android:name=".MyAppService">
        <intent-filter>
            <action
                android:name = "me.myapp.MyAppService">
            </action>
        </intent-filter>
    </service>
    <receiver
        android:enabled="true"
        android:name=".BootReceiver">
        <intent-filter>
            <action android:name = "android.intent.action.BOOT_COMPLETED"/>
        </intent-filter>
    </receiver>
</application>
Run this command in command Promt
adb shell am broadcast -a android.intent.action.BOOT_COMPLETED


22.What is json? how do you parse it?
JSON (JavaScript Object Notation) is a lightweight format that is used for data interchanging. It is also a subset of JavaScript's 
Object Notation (the way objects are built in JavaScript)

An example of where this is used is web services responses. In the 'old' days, web services used XML as their primary data format for transmitting 
back data, but since JSON appeared (The JSON format is specified in RFC 4627 by Douglas Crockford), it has been the preferred format because it is 
much more lightweight

You can find a lot more info on one of Crockford's sites here

JSON is built on two structures:

A collection of name/value pairs. In various languages, this is realized as an object, record, struct, dictionary, hash table, keyed list, or associative
 array.
An ordered list of values. In most languages, this is realized as an array, vector, list, or sequence.



What is rest web service? What is the difference between rest and soap web service?


REST

The RESTful Web services are completely stateless. This can be tested by restarting the server and checking if the interactions are able to survive.
Restful services provide a good caching infrastructure over HTTP GET method (for most servers). This can improve the performance, if the data the 
Web service returns is not altered frequently and not dynamic in nature.
The service producer and service consumer need to have a common understanding of the context as well as the content being passed along as there is 
no standard set of rules to describe the REST Web services interface.
REST is particularly useful for restricted-profile devices such as mobile and PDAs for which the overhead of additional parameters like headers and
 other SOAP elements are less.
REST services are easy to integrate with the existing websites and are exposed with XML so the HTML pages can consume the same with ease. There is 
hardly any need to refactor the existing website architecture. This makes developers more productive and comfortable as they will not have to rewrite
 everything from scratch and just need to add on the existing functionality.
REST-based implementation is simple compared to SOAP.
SOAP

The Web Services Description Language (WSDL) contains and describes the common set of rules to define the messages, bindings, operations and location 
of the Web service. WSDL is a sort of formal contract to define the interface that the Web service offers.
SOAP requires less plumbing code than REST services design, (i.e., transactions, security, coordination, addressing, trust, etc.) Most real-world 
applications are not simple and support complex operations, which require conversational state and contextual information to be maintained. With the
 SOAP approach, developers need not worry about writing this plumbing code into the application layer themselves.
SOAP Web services (such as JAX-WS) are useful in handling asynchronous processing and invocation.
SOAP supports several protocols and technologies, including WSDL, XSDs, SOAP, WS-Addressing
In a nutshell, when you're publishing a complex application program interface (API) to the outside world, SOAP will be more useful. But when something 
with a lower learning curve, and with lightweight and faster results and simple transactions (i.e., CRUD operations) is needed, my vote goes to REST.

Example of a GET request

If a "GET" request is used, the form parameters are encoded in the URL in what is called a query string. The form parameters can be anything, and in the example we gave earlier they would be the username and password for your email provider. Here’s an example of the query string that would be generated if we were to use a "GET" request:

www.someemailprovider.com/?login=joe@email.com&password=xxyz 

In the GET request above, you can see that the form parameters (login and password) are attached to the end of the URL itself. Note that defining a login form to use the GET request method – as we did in this example – is a very bad idea. This is because people logging in will see their passwords being displayed in the url and may be led to think that your site is not secure. One should almost always use a POST form whenever passwords are involved, for other reasons that are explained below.

A POST request, unlike a GET request, passes the form parameters in the body of the HTTP request, not in the URL. This happens behind the scenes, in what can be thought of as an HTTP ‘dialogue’ between your web browser and a webserver. 

Serialization is the conversion of an object to a series of bytes, so that the object can be easily saved to persistent storage or streamed 
across a communication link. The byte stream can then be deserialized - converted into a replica of the original object.




IPAddress Matching

"^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
		"([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
		"([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
		"([01]?\\d\\d?|2[0-4]\\d|25[0-5])$";



"^(([01]?\\d{1,2})|(2[0-5]{0,2}))(\\.(([01]?\\d{1,2})|(2[0-5]{0,2}))){3}$";




getContext

    Context represents environment data
    It provides access to things such as databases


    getApplicationContext() - Returns the context for all activities running in application.

    getBaseContext() - If you want to access Context from another context within application you can access.

    getContext() - Returns the context view only current running activity.

Bundle in Android?

Bundle is generally used for passing data between various activities of android. It depends on you what type of values you want to pass, but bundle can hold all types of values, and pass to the new activity.


When do we call onUpgrade in sqlite through activity?

SQLiteOpenHelper onCreate() and onUpgrade() callbacks are invoked when the database is actually opened, for example by a call to getWritableDatabase(). The database is not opened when the database helper object itself is created.

SQLiteOpenHelper versions the database files. The version number is the int argument passed to the constructor. In the database file, the version number is stored in PRAGMA user_version.

onCreate() is only run when the database file did not exist and was just created. If onCreate() returns successfully (doesn't throw an exception), the database is assumed to be created with the requested version number. As an implication, you should not catch SQLExceptions in onCreate() yourself.

onUpgrade() is only called when the database file exists but the stored version number is lower than requested in constructor. The onUpgrade() should update the table schema to the requested version.

When changing the table schema in code (onCreate()), you should make sure the database is updated. Two main approaches:

    Delete the old database file so that onCreate() is run again. This is often preferred at development time where you have control over the installed versions and data loss is not an issue. Some ways to to delete the database file:

        Uninstall the application. Use the application manager or adb uninstall your.package.name from shell.

        Clear application data. Use the application manager.

    Increment the database version so that onUpgrade() is invoked. This is slightly more complicated as more code is needed.

        For development time schema upgrades where data loss is not an issue, you can just use execSQL("DROP TABLE IF EXISTS <tablename>") in to remove your existing tables and call onCreate() to recreate the database.

        For released versions, you should implement data migration in onUpgrade() so your users don't lose their data.


What is difference between viewgroup and views?
View is a basic building block of UI (User Interface) in android. A view is a small rectangular box which responds to user inputs. Eg: EditText, Button, CheckBox, etc..

ViewGroup is a invisible container of other views (child views) and other viewgroups. Eg: LinearLayout is a viewgroup which can contain other views in it.

ViewGroup is a special kind of view which is extended from View as its base class. ViewGroup is the base class for layouts.

as name states View is singular and the group of Views is the ViewGroup.



In the Android SDK documentation, there are 4 terms used to refer to different parts of the user interface (UI) class hierarchy:

    View - Refer to the android.view.View class, which is the base class of all UI classes. android.view.View class is the root of the UI class hierarchy. So from an object point of view, all UI objects are View objects.
    ViewGroup - Refer to the android.view.ViewGroup class, which is the base class of some special UI classes that can contain other View objects as children. Since ViewGroup objects are also View objects, multiple ViewGroup objects and View objects can be organized into an object tree to build complex UI structure.
    Widget - Refer to any UI class that provides a specific simple or complex UI function. A simple Widget can use single View object. A complex Widget can use a View object tree with many ViewGroup objects and View objects.
    Layout - Refer to any UI class that is specially designed to place child View objects into a UI pattern. Obviously, a Layout has to be a subclass of the android.view.View.ViewGroup.


How to pass objects between activities?

Deneme cls has to be Serialized by extending Serializable

Deneme dene = new Deneme(4,"Mustafa");
Intent i = new Intent(this, Y.class);
i.putExtra("sampleObject", dene);
startActivity(i);

Intent i = getIntent();
Deneme dene = (Deneme)i.getSerializableExtra("sampleObject");


mport java.io.Serializable;

@SuppressWarnings("serial") //with this annotation we are going to hide compiler warning
public class Deneme implements Serializable {

public Deneme(double id, String name){
    this.id = id;
    this.name = name;
}

public double getId() {
    return id;
}
public void setId(double id) {
    this.id = id;
}
public String getName() {
    return this.name;
}
public void setName(String name) {
    this.name = name;
}

private double id;
private String name;

}s




what is backstack in android?

Back navigation is how users move backward through the history of screens they previously visited. All Android devices provide a Back button for this type of navigation, so your app should not add a Back button to the UI.

In almost all situations, the system maintains a back stack of activities while the user navigates your application. This allows the system to properly navigate backward when the user presses the Back button. However, there are a few cases in which your app should manually specify the Back behavior in order to provide the best user experience.

Service vs IntentService ?
When to use?

    The Service can be used in tasks with no UI, but shouldn't be too long. If you need to perform long tasks, you must use threads within Service.

    The IntentService can be used in long tasks usually with no communication to Main Thread. If communication is required, can use Main Thread handler or broadcast intents. Another case of use is when callbacks are needed (Intent triggered tasks).

How to trigger?

    The Service is triggered by calling method startService().

    The IntentService is triggered using an Intent, it spawns a new worker thread and the method onHandleIntent() is called on this thread.

Triggered From

    The Service and IntentService may be triggered from any thread, activity or other application component.

Runs On

    The Service runs in background but it runs on the Main Thread of the application.

    The IntentService runs on a separate worker thread.

Limitations / Drawbacks

    The Service may block the Main Thread of the application.

    The IntentService cannot run tasks in parallel. Hence all the consecutive intents will go into the message queue for the worker thread and will execute sequentially.

When to stop?

    If you implement a Service, it is your responsibility to stop the service when its work is done, by calling stopSelf() or stopService(). (If you only want to provide binding, you don't need to implement this method).

    The IntentService stops the service after all start requests have been handled, so you never have to call stopSelf().


how you will handle back stack for fragment in android?

private final static String TAG_FRAGMENT = "TAG_FRAGMENT";

private void showFragment() {
    final Myfragment fragment = new MyFragment();
    final FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
    transaction.replace(R.id.fragment, fragment, TAG_FRAGMENT);
    transaction.addToBackStack(null);
    transaction.commit();
}

@Override
public void onBackPressed() {
    final Myfragment fragment = (Myfragment) getSupportFragmentManager().findFragmentByTag(TAG_FRAGMENT);

    if (fragment.allowBackPressed()) { // and then you define a method allowBackPressed with the logic to allow back pressed or not
        super.onBackPressed();
    }
}


Handler in android?

Handler h = new Handler(){
    @Override
    public void handleMessage(Message msg){
        if(msg.what == 0){
            updateUI();
        }else{
            showErrorDialog();
        }
    }
};

Thread t = new Thread() {
    @Override
    public void run(){
        doSomeWork();
        if(succeed){
            //we can't update the UI from here so we'll signal our handler and it will do it for us.
            h.sendEmptyMessage(0);
        }else{
            h.sendEmptyMessage(1);
        }
    }   


 Why we use handlers with thread :

When we install an application in android then it create a thread  for that application called MAIN UI Thread, All activities run inside that thread , By the android single thread model rule we can not access UI elements (bitmap , textview etc..) directly for another thread defined inside that activity.
 
 So if want to access Main UI Thread elements by another thread then we will use  handlers.
Thread With Handlers Example :

In this example  we are creating a thread and call webservice to get server response and after got the response,then do other functionality ( Save Data in database or show alert ,Redirect to another activity).
};


28.loading Image Url to ImageView in aNdroid?

private class DownloadImageTask extends AsyncTask<String, Void, Bitmap> {
    ImageView bmImage;

    public DownloadImageTask(ImageView bmImage) {
        this.bmImage = bmImage;
    }

    protected Bitmap doInBackground(String... urls) {
        String urldisplay = urls[0];
        Bitmap mIcon11 = null;
        try {
            InputStream in = new java.net.URL(urldisplay).openStream();
            mIcon11 = BitmapFactory.decodeStream(in);
        } catch (Exception e) {
            Log.e("Error", e.getMessage());
            e.printStackTrace();
        }
        return mIcon11;
    }

    protected void onPostExecute(Bitmap result) {
        bmImage.setImageBitmap(result);
    }




29.Looper in Android?
A Looper is a message handling loop: it reads and processes items from a MessageQueue. The Looper class is usually used in conjunction with a HandlerThread (a subclass of Thread).

A Handler is a utility class that facilitates interacting with a Looper—mainly by posting messages and Runnable objects to the thread's MessageQueue. When a Handler is created, it is bound to a specific Looper (and associated thread and message queue).

In typical usage, you create and start a HandlerThread, then create a Handler object (or objects) by which other threads can interact with the HandlerThread instance. The Handler must be created while running on the HandlerThread, although once created there is no restriction on what threads can use the Handler's scheduling methods (post(Runnable), etc.)

The main thread (a.k.a. UI thread) in an Android application is set up as a looper thread before your application is created.
